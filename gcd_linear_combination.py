def linear_combination(a,b):
    if a == 0: # Для случаев, когда одно из чисел = 0, линейное представление тривиально
        return(0, 1)
    elif b == 0:
        return(1, 0)
    else: # Оба числа отличны от 0
        q = a // b # Запишем первый шаг алгоритма Евклида для случая, когда a кратно b
        r = a % b 
        
        a = b
        b = r

        x2 = 0 
        x1 = 1
        x= 1

        y2 = 1
        y1 = -q
        y = -q

        if (b == 0): # Если a было кратно b, то линейное представление уже знаем - выводим
            return (x, y + 1) # y + 1 т.к. НОД - меньшее из чисел, q  - частное, y = -q, a = qb, b = a + b(1 - q), b = a - b(q - 1)

        while (a % b != 0): # Вычисление коэффициентов Безу с помощью расширенного Алгоритма Евклида 
            
            q = a // b
            r = a % b

            a = b
            b = r

            x = -q * x1 + x2
            y = -q * y1 + y2

            x2 = x1
            x1 = x
            
            y2 = y1
            y1 = y

        return (x, y)



a = int(input('Первое число: '))
b = int(input('Второе число: '))

gcd = a*linear_combination(a,b)[0]+b*linear_combination(a,b)[1] # Вычислим НОД, зная его линейное представление. Потеряли "положительность", но НОД определён с точностью до ассоциированности.
print('НОД = ', gcd) 
print (gcd, ' = ','(', a,')',' * ', '(',linear_combination(a,b)[0],')',' + ','(',b,')', ' * ', '(',linear_combination(a,b)[1],')') # Выводим линейное представление
